module Wice
  module GridViewHelper

    # This method dumps all HTTP parameters related to filtering and ordering of a certain grid as hidden form fields. 
    # This might be required if you want to keep the state of a grid while reloading the page using other forms.
    # 
    # The only parameter is a grid object returned by +initialize_grid+ in the controller. 
    def dump_filter_parameters_as_hidden_fields(grid)
      unless grid.kind_of? WiceGrid
        raise WiceGridArgumentError.new("dump_filter_parameters_as_hidden_fields: the parameter must be a WiceGrid instance.")
      end

      (if filters = grid.status[:f]
        filters.parameter_names_and_values([grid.name, 'f']).collect do |name, value|
          hidden_field_tag(name, value) 
        end
      else
        []
      end + 
      [:order, :order_direction].select{|parameter| grid.status[parameter] }.collect do |parameter|
          hidden_field_tag("#{grid.name}[#{parameter}]", grid.status[parameter])
      end).join("\n")
      
    end
    
    # View helper for rendering the grid.
    #
    # The first parameter is a grid object returned by +initialize_grid+ in the controller. 
    # 
    # The second parameter is a hash of options:
    # * <tt>:table_html_attrs</tt> - a hash of HTML attributes to be included into the <tt>table</tt> tag.
    # * <tt>:header_tr_html_attrs</tt> - a hash of HTML attributes to be included into the first <tt>tr</tt> tag 
    #   (or two first <tt>tr</tt>'s if the filter row is present).
    # * <tt>:show_filters</tt> - defines when the filter is shown. Possible values are:
    #   * <tt>:when_filtered</tt> - the filter is shown when the current table is the result of filtering
    #   * <tt>:always</tt>        - show the filter always
    #   * <tt>:no</tt>            - never show the filter
    # * <tt>:upper_pagination_panel</tt> - a boolean value which defines whether there is an additional pagination 
    #   panel on top of the table. By default it is false.
    # * <tt>:extra_request_parameters</tt> - a hash which will be added as additional HTTP request parameters to all links generated by the grid,
    #   be it sorting links, filters, or the 'Reset Filter' icon. Please note that WiceGrid respects and retains all request parameters already
    #   present in the URL which formed the page, so there is no need to enumerate them in <tt>:extra_request_parameters</tt>. A typical
    #   usage of <tt>:extra_request_parameters</tt> is a page with javascript tabs - changing the active tab does not reload the page, but if
    #   one such tab contains a WiceGrid, it could be required that if the user orders or filters the grid, the result page should have the tab 
    #   with the grid activated. For this we need to send an additional parameter specifying from which tab the request was generated.
    # * <tt>:sorting_dependant_row_cycling</tt> - When set to true (by default it is false) the row styles +odd+ and +even+ will be changed
    #   only when the content of the cell belonging to the sorted column changes. In other words, rows with identical values in the ordered
    #   column will have the same style (color).
    #
    # The block contains definitions of grid columns using the +column+ method sent to the object yielded into the block. In other words,
    # the value returned by each of the blocks defines the content of a cell, the first block is called for cells of the first column
    # for each row (each ActiveRecord instance), the second block is called for cells of the second column, and so on. See the example:
    #
    #   <%= grid(@accounts_grid, :table_html_attrs => {:class => 'grid_style', :id => 'accounts_grid'}, :header_tr_html_attrs => {:class => 'grid_headers'}) do |g|
    # 
    #     g.column :column_name => 'Username', :attribute_name => 'username' do |account|  
    #       account.username
    #     end
    # 
    #     g.column :column_name => 'application_account.field.identity_id'._, :attribute_name => 'firstname', :model_class =>  Person do |account|
    #       link_to(account.identity.name, identity_path(account.identity))
    #     end 
    # 
    #     g.column do |account|
    #       link_to('Edit', edit_account_path(account))
    #     end
    #
    #   end -%>
    #
    # The helper may have two styles defined by the +erb_mode+ parameter to the +initialize_grid+ in the contoller.
    # By default (<tt>erb_mode = false</tt>) this is a simple helper surrounded by <tt><%=</tt> and <tt>%></tt>:
    #     
    #     <%= grid(@countries_grid) do |g|
    # 
    #       g.column :column_name => 'Name', :attribute_name => 'name' do |country|
    #         link_to(country.name, country_path(country))
    #       end
    # 
    #       g.column :column_name => 'Numeric Code', :attribute_name => 'numeric_code' do |country|
    #         country.numeric_code
    #       end
    # 
    #     end -%>
    # 
    # 
    # 
    # The second style (<tt>erb_mode = true</tt>) is called <em>ERB mode</em> and it allows to embed any ERB content inside blocks, 
    # which is basically the style of the 
    # <tt>form_for</tt> helper, only <tt>form_for</tt> takes one block, while inside the <tt>grid</tt> block there are other method calls taking
    # blocks as parameters:
    # 
    #     <% grid(@countries_grid) do |g| 
    # 
    #       <% g.column :column_name => 'Name', :attribute_name => 'name' do |country| %>
    #         <b>Name: <%= link_to(country.name, country_path(country)) %></b>
    #       <% end %>
    # 
    #       <% g.column :column_name => 'Numeric Code', :attribute_name => 'numeric_code' do |country| %>
    #         <i>Numeric Code: <%= country.numeric_code %></i>
    #       <% end %>
    # 
    #     <% end -%>
    # 
    # This mode can be usable if you like to have much HTML code inside cells.
    # 
    # Please remember that in this mode the helper opens with <tt><%</tt> instead of <tt><%=</tt>, similar to <tt>form_for</tt>.
    # 
    # Defaults for parameters <tt>:show_filters</tt> and <tt>:upper_pagination_panel</tt>
    # can be changed in <tt>lib/wice_grid_config.rb</tt> using constants <tt>Wice::Defaults::SHOW_FILTER</tt> and 
    # <tt>WiceGrid::Defaults::SHOW_UPPER_PAGINATION_PANEL</tt>, this is convenient if you want to set a project wide setting
    # without having to repeat it for every grid instance.
    #
    # Pease read documentation about the +column+ method to achieve the enlightenment.
    
    def grid(grid, opts = {}, &block) 
      raise WiceGridArgumentError.new("The first argument for the grid helper must be an instance of the WiceGrid class") unless grid.class == WiceGrid

      table_html_attrs = {:class => "wice_grid"}
      header_tr_html_attrs = {}

      Wice.deprecated_call(:table_html_opts, :table_html_attrs, opts)
      Wice.deprecated_call(:header_tr_html_opts, :header_tr_html_attrs, opts)

      if opts[:table_html_attrs]
        table_html_attrs.merge!(opts[:table_html_attrs])
        opts.delete(:table_html_attrs)
      end

      if  opts[:header_tr_html_attrs]
        header_tr_html_attrs.merge!(opts[:header_tr_html_attrs]) 
        opts.delete(:table_html_attrs)      
      end

      options = {
        :guts_only => false,
        :show_filters => Defaults::SHOW_FILTER, 
        :upper_pagination_panel => Defaults::SHOW_UPPER_PAGINATION_PANEL,
        :sorting_dependant_row_cycling => false,
        :extra_request_parameters => {}}
      options.merge!(opts)


      rendering = GridRenderer.new(grid)
      block.call(rendering) # calling block containing column() calls

      if options[:guts_only]
        content = grid_content(grid, table_html_attrs, header_tr_html_attrs, options, rendering)
      elsif grid.output_csv?
        content = grid_css(grid, rendering)
      else
        content = grid_html(grid, table_html_attrs, header_tr_html_attrs, options, rendering)
      end
      
      if grid.erb_mode?
        return concat(content, block.binding)
      else
        return content
      end
    end

    def grid_html(grid, table_html_attrs, header_tr_html_attrs, options, rendering) #:nodoc:

      cycle_class = nil
      sorting_dependant_row_cycling = options[:sorting_dependant_row_cycling]
      content = javascript_include_tag 'wice_grid'
      content += "<table #{tag_options(table_html_attrs, true)}>"
      content += "<thead>"
    
      if options[:upper_pagination_panel]
        content += rendering.pagination_panel{ 
          will_paginate(grid.resultset, :param_name => "#{grid.name}[page]", :params => options[:extra_request_parameters] )
        }
      end

      content += "<tr #{tag_options(header_tr_html_attrs, true)}>"

      # first row of column labels with sorting links
      col_class = "col1"
      rendering.each_column(:in_html) do |column|
        if column.attribute_name 

          css_class = grid.filtered_by?(column) ? 'active_filter' : nil

          direction = 'asc'
          link_style = nil
          if grid.ordered_by?(column)
            css_class = css_class.nil? ? 'sorted' : css_class + ' sorted'
            link_style = grid.order_direction
            direction = 'desc' if grid.order_direction == 'asc'
          end

          col_link = link_to(
            column.column_name,
            rendering.column_link(column, direction, params, options[:extra_request_parameters]), 
            :class => link_style)
          css_class = css_class.nil? ? col_class : css_class + ' ' + col_class
          content += content_tag(:th, col_link, Hash.make_hash(:class, css_class))
          column.css_class = css_class
        else
          content += content_tag(:th, column.column_name, Hash.make_hash(:class, col_class))
        end
        col_class = col_class.next
      end
      # rendering first row end
        
      filter_shown = if options[:show_filters] == :when_filtered
        grid.filtering_on?
      elsif options[:show_filters] == :always
        true
      end

      no_rightmost_column = no_filter_row = (options[:show_filters] == :no || rendering.no_filter_needed?) ? true: false

      no_filter_opening_closing_icon = (options[:show_filters] == :always) || no_filter_row
      
      styles = ["display: block;", "display: none;"]
      styles.reverse! unless filter_shown
      hide_icon_id = grid.name + '_hide_icon'
      show_icon_id = grid.name + '_show_icon'
      filter_row_id = grid.name + '_filter_row'

      if no_filter_opening_closing_icon
        hide_icon = show_icon = ''
      else
        hide_icon = content_tag(:span, 
          link_to_function(
            image_tag(Defaults::SHOW_HIDE_FILTER_ICON, 
              :title => Defaults::HIDE_FILTER_TOOLTIP, 
              :alt => Defaults::HIDE_FILTER_TOOLTIP), 
            "Element.toggle('#{show_icon_id}'); Element.toggle('#{hide_icon_id}'); "  + 
              visual_effect(:fade, filter_row_id, :duration => 0.5, :queue => 'front') ),
          :id => hide_icon_id,
          :style => styles[0]
        )

        show_icon = content_tag(:span, 
          link_to_function(
            image_tag(Defaults::SHOW_HIDE_FILTER_ICON, 
              :title => Defaults::SHOW_FILTER_TOOLTIP, 
              :alt => Defaults::SHOW_FILTER_TOOLTIP), 
            "Element.toggle('#{show_icon_id}'); Element.toggle('#{hide_icon_id}'); " + 
              visual_effect(:appear, filter_row_id, :duration => 0.5, :queue => 'front') ),
          :id => show_icon_id,
          :style => styles[1]
        )
        
      end
      content += content_tag(:th, hide_icon + show_icon) unless no_rightmost_column
      content += '</tr>'
  

      # second row with filters
      unless no_filter_row
    
        content += "<tr id=\"#{filter_row_id}\""
        content += 'style="display:none"' unless filter_shown
        content += '>'      
    
        rendering.each_column(:in_html) do |column|
          if column.filter_shown?
            content += content_tag(:th, column.render_filter, Hash.make_hash(:class, column.css_class))
          else
            content += content_tag(:th, '', Hash.make_hash(:class, column.css_class))
          end
        end
    
        content += content_tag(:th, 
          link_to_function(
            image_tag(Defaults::FILTER_ICON, 
              :title => Defaults::FILTER_TOOLTIP, 
              :alt => Defaults::FILTER_TOOLTIP), "#{grid.name}.process()") + 
          ' ' + 
          link_to_function(
            image_tag(Defaults::RESET_ICON,  
              :title => Defaults::RESET_FILTER_TOOLTIP, 
              :alt => Defaults::RESET_FILTER_TOOLTIP), "#{grid.name}.reset()")
        ) 

        content += '</tr>'
      end
      # rendering second row end
      
      content += "</thead>"
      content += "<tbody id='#{table_html_attrs[:id] + '_target'}'>"

      rendering.each_column(:in_html) do |column|
        unless column.css_class.blank?
          column.td_html_attrs.add_or_append_class_value(column.css_class)
        end
      end
      
      # rendering  rows
      cell_value_of_the_ordered_column = nil
      previous_cell_value_of_the_ordered_column = nil
      grid.each do |ar| # rows
        
        row_content = ''
        rendering.each_column(:in_html) do |column|
          cell_block = column.cell_rendering_block

          opts = column.td_html_attrs.clone
          column_block_output = if grid.erb_mode?
            capture(ar, &cell_block)
          else
            cell_block.call(ar)
          end
          
          if column_block_output.kind_of?(Array)
            column_block_output, additional_opts = column_block_output
            additional_css_class = nil
            if additional_opts.has_key?(:class)
              additional_css_class = additional_opts[:class]
              additional_opts.delete(:class)
            elsif additional_opts.has_key?('class')
              additional_css_class = additional_opts['class']
              additional_opts.delete('class')              
            end
            opts.merge!(additional_opts)
            opts.add_or_append_class_value(additional_css_class) unless additional_css_class.blank?
          end
          if sorting_dependant_row_cycling && column.attribute_name && grid.ordered_by?(column)
            cell_value_of_the_ordered_column = column_block_output
          end
          row_content += content_tag(:td, column_block_output, opts)
        end

        row_attributes = rendering.get_row_attributes(ar)

        if sorting_dependant_row_cycling
          cycle_class = cycle('odd', 'even', :name => grid.name) if cell_value_of_the_ordered_column != previous_cell_value_of_the_ordered_column
          previous_cell_value_of_the_ordered_column = cell_value_of_the_ordered_column
        else
          cycle_class = cycle('odd', 'even', :name => grid.name)
        end
        
        row_attributes.add_or_append_class_value(cycle_class)
                
        content += "<tr #{tag_options(row_attributes)}>#{row_content}"
        content += content_tag(:td, '') unless no_rightmost_column
        content += '</tr>'      

      end
      
      content += '</tbody>'
      content += '</table>'

      #content += will_paginate(grid.resultset, :param_name => "#{grid.name}[page]", :params => options[:extra_request_parameters])
    
      base_link_for_filter = rendering.base_link_for_filter(controller, options[:extra_request_parameters])
      link_for_export      = rendering.link_for_export(controller, 'csv', options[:extra_request_parameters])
      content += javascript_tag(
        "#{grid.name} = new WiceGridProcessor('#{grid.name}', '#{base_link_for_filter}', '#{link_for_export}');\n" +
        rendering.select{|vc|vc.attribute_name and not vc.no_filter}.collect{|column|  column.yield_javascript}.join("\n")
      )
      return content
    end
    
    def grid_content(grid, table_html_attrs, header_tr_html_attrs, options, rendering) #:nodoc:
      
      content = ""
      
      # first row of column labels with sorting links
      col_class = "col1"
      rendering.each_column(:in_html) do |column|
        if column.attribute_name 

          css_class = grid.filtered_by?(column) ? 'active_filter' : nil

          direction = 'asc'
          link_style = nil
          if grid.ordered_by?(column)
            css_class = css_class.nil? ? 'sorted' : css_class + ' sorted'
            link_style = grid.order_direction
            direction = 'desc' if grid.order_direction == 'asc'
          end

          col_link = link_to(
            column.column_name,
            rendering.column_link(column, direction, params, options[:extra_request_parameters]), 
            :class => link_style)
          css_class = css_class.nil? ? col_class : css_class + ' ' + col_class
          column.css_class = css_class
        end
        col_class = col_class.next
      end
      # rendering first row end
      
      no_rightmost_column = no_filter_row = (options[:show_filters] == :no || rendering.no_filter_needed?) ? true: false
      cycle_class = nil
      sorting_dependant_row_cycling = options[:sorting_dependant_row_cycling]

      rendering.each_column(:in_html) do |column|
        unless column.css_class.blank?
          column.td_html_attrs.add_or_append_class_value(column.css_class)
        end
      end
      
      # rendering  rows
      cell_value_of_the_ordered_column = nil
      previous_cell_value_of_the_ordered_column = nil
      grid.each do |ar| # rows
        
        row_content = ''
        rendering.each_column(:in_html) do |column|
          cell_block = column.cell_rendering_block

          opts = column.td_html_attrs.clone
          column_block_output = if grid.erb_mode?
            capture(ar, &cell_block)
          else
            cell_block.call(ar)
          end
          
          if column_block_output.kind_of?(Array)
            column_block_output, additional_opts = column_block_output
            additional_css_class = nil
            if additional_opts.has_key?(:class)
              additional_css_class = additional_opts[:class]
              additional_opts.delete(:class)
            elsif additional_opts.has_key?('class')
              additional_css_class = additional_opts['class']
              additional_opts.delete('class')              
            end
            opts.merge!(additional_opts)
            opts.add_or_append_class_value(additional_css_class) unless additional_css_class.blank?
          end
          if sorting_dependant_row_cycling && column.attribute_name && grid.ordered_by?(column)
            cell_value_of_the_ordered_column = column_block_output
          end
          row_content += content_tag(:td, column_block_output, opts)
        end

        row_attributes = rendering.get_row_attributes(ar)

        if sorting_dependant_row_cycling
          cycle_class = cycle('odd', 'even', :name => grid.name) if cell_value_of_the_ordered_column != previous_cell_value_of_the_ordered_column
          previous_cell_value_of_the_ordered_column = cell_value_of_the_ordered_column
        else
          cycle_class = cycle('odd', 'even', :name => grid.name)
        end
        
        row_attributes.add_or_append_class_value(cycle_class)
                
        content += "<tr #{tag_options(row_attributes)}>#{row_content}"
        content += content_tag(:td, '') unless no_rightmost_column
        content += '</tr>'      

      end
      
      return content
    end
    

    def grid_css(grid, rendering) #:nodoc:

      spreadsheet = Spreadsheet.new(grid.name)

      # columns
      spreadsheet << rendering.column_labels(:in_csv)
      
      # rendering  rows
      grid.each do |ar| # rows
        row = []
        
        rendering.each_column(:in_csv) do |column|
          cell_block = column.cell_rendering_block

          column_block_output = if grid.erb_mode?
            capture(ar, &cell_block)
          else
            cell_block.call(ar)
          end

          if column_block_output.kind_of?(Array)
            column_block_output, additional_opts = column_block_output
          end
          
          row << column_block_output
        end
        spreadsheet << row
      end
      spreadsheet.close
      return spreadsheet.path
    end
    
  end
end